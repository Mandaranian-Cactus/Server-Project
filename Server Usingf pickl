Client
import pygame
from network import Network

width = 500
height = 500
win = pygame.display.set_mode((width, height))
pygame.display.set_caption("Client")

def redrawWindow(win,player, player2):
    win.fill((255,255,255))
    player.draw(win)
    player2.draw(win)
    pygame.display.update()


def main():
    run = True
    # Network is essentially the conversation
    n = Network()   # Network is set up and begins an infinite loop through threading in server.py
    p = n.getP()    # Get the initial position
    clock = pygame.time.Clock()

    while run:
        clock.tick(60)
        p2 = n.send(p)      # send info of p1 then get info of p2

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                run = False
                pygame.quit()

        p.move()
        redrawWindow(win, p, p2)

main()




network
import socket
import pickle

class Network:
    def __init__(self):
        self.client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.server = "192.168.0.29"
        self.port = 5555
        self.addr = (self.server, self.port)
        self.p = self.connect()

    def getP(self):
        return self.p

    def connect(self):
        try:
            self.client.connect(self.addr)
            return pickle.loads(self.client.recv(2048))     # Load incoming info (Player info as an object)
        except:
            pass

    def send(self, data):
        try:
            self.client.send(pickle.dumps(data))    # Send info of a player
            return pickle.loads(self.client.recv(2048))     # Receive info of the other player
        except socket.error as e:
            print(e)



player
port pygame

class Player():
    def __init__(self, x, y, width, height, color):
        self.x = x
        self.y = y
        self.width = width
        self.height = height
        self.color = color
        self.rect = [x,y,width,height]  # Shortcut for drawing
        self.vel = 3    # Speed as scalar

    def draw(self, win):    # Draw player
        pygame.draw.rect(win, self.color, self.rect)

    def move(self):     # Wanna edit player movements
        keys = pygame.key.get_pressed()     # Check for any key presses

        # Edit positions accordingly
        if keys[pygame.K_LEFT]:
            self.x -= self.vel

        if keys[pygame.K_RIGHT]:
            self.x += self.vel

        if keys[pygame.K_UP]:
            self.y -= self.vel

        if keys[pygame.K_DOWN]:
            self.y += self.vel

        self.update()        # Edit the shortcut as well

    def update(self):   # Edit shortcut shortcut
        self.rect = (self.x, self.y, self.width, self.height)
        
        
        
        
        
        
        
Server
import socket
from _thread import *
from player import Player
import pickle

# Server script will always need to be running
# Sever script needs to be run on a machine with the same wifi as the clients

server = "192.168.0.29"
port = 5555     # Often open port
players = [Player(50, 50, 50, 50, (255, 0, 0)), Player(100, 100, 50, 50, (0, 0, 255))]
player_cnt = 0  # Number of players present

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

try:
    s.bind((server, port))
except socket.error as e:   # We have an error where a port may not be available or ip address is incorrect
    str(e)

s.listen(2)     # number of people that cn connect onto the server
print("Waiting for a connection, Server Started")   # By this part, we have gotten the server creation done

players = [Player(0,0,50,50,(255,0,0)), Player(100,100, 50,50, (0,0,255))]      # Stores the info of each player

def threaded_client(conn, player):
    global player_cnt
    # Pickle.dumps pretty sure deconstructs the info to store an object
    conn.send(pickle.dumps(players[player]))    # Sends initial info of the player
    reply = ""
    while True:
        try:
            data = pickle.loads(conn.recv(2048))    # Receives and reconstructs the data (Of the player as an object)
            players[player] = data   # Edit the player info

            # Begins to set up a reply
            if not data:    # No data was given
                print("Disconnected")
                break
            else:
                # Give info of the other player
                if player == 1:
                    reply = players[0]  # Reply is now player 1's info
                else:
                    reply = players[1]  # Reply is now player 2's info

            conn.sendall(pickle.dumps(reply))   # Sends the info of the other player (info of b to a)
        except:     # In-case of any errors, break
            break

    print("Lost connection")
    conn.close()    # Disconnect connection
    player_cnt -= 1  # A player has left

while True:
    conn, addr = s.accept()     # Accepts a connection and ip address (In that order)
    print("Connected to:", addr)

    start_new_thread(threaded_client, (conn, player_cnt))
    player_cnt += 1
